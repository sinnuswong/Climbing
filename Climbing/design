2.1 世界模型（3D 体素 / Voxel Grid）

地图空间表示为一个三维离散网格（体素）：

solid(x, y, z) ∈ {true, false}

(x, y) 为平面网格坐标，z 为高度层（从 0 开始）

solid(x,y,z)=true 表示该位置存在一个单位立方体方块；false 表示为空。

该体素模型允许出现以下结构：

悬空平台：某个方块下方为空（solid(x,y,z)=true 但 solid(x,y,z-1)=false）

桥/拱/洞：同一 (x,y) 列可存在“中间为空”的空腔结构

非连续堆叠：不要求方块从地面连续堆到顶

地图边界由固定尺寸约束：x ∈ [0, W-1], y ∈ [0, H-1], z ∈ [0, Z-1]

设计约束（MVP 推荐）：为控制复杂度和性能，建议 Z 不超过 10–16，W、H 不超过 12–20。

2.2 可站立位置（Walkable Surface Definition）

玩家只能站在“方块的顶面”。定义一个体素 (x,y,z) 的顶面可站立当且仅当：

solid(x,y,z) == true（该处有方块）

solid(x,y,z+1) == false（方块上方为空，顶面暴露）

将所有满足上述条件的体素称为 站点（Stand Node）。

2.3 玩家状态（Player State）

玩家始终处于某个站点上。

玩家状态定义为三元组：

P = (x, y, z)
其中 (x,y,z) 必须为站点（满足 2.2 条件）。

玩家“当前高度”以 z 表示（即脚下方块的高度层）。

2.4 移动规则（严格）

玩家每次只能向四邻域（上/下/左/右）移动一格平面坐标：

相邻格定义：(nx, ny) ∈ {(x+1,y),(x-1,y),(x,y+1),(x,y-1)}

移动的关键是：在目标平面坐标 (nx,ny) 上选择一个可落脚的站点 (nx,ny,nz)。

2.4.1 目标落脚站点选择（Landing Resolution）

在目标列 (nx,ny) 中，所有站点集合为：

S(nx,ny) = { z | solid(nx,ny,z)=true 且 solid(nx,ny,z+1)=false }

移动时从 S(nx,ny) 中选择一个 nz 作为落脚高度。MVP 推荐规则：

优先选择“最高且满足爬升限制”的站点：

选择 nz 使得：

nz ∈ S(nx,ny)

nz - z ≤ 1（最多上升 1 层）

在所有满足条件的 nz 中取最大值（离地更高者优先）

如果不存在满足 nz - z ≤ 1 的站点：

若允许“任意下降”，则可选择所有 nz < z 的站点中“最高的那个”

若不允许任意下降（可选严格模式），则设置最大下落高度限制，例如 z - nz ≤ D

MVP 建议：允许任意下降，以减少无谓限制与关卡死锁。

2.4.2 合法移动判定

从 (x,y,z) 移动到 (nx,ny,nz) 合法当且仅当：

(nx,ny) 在地图边界内

(nx,ny,nz) 是站点（顶面暴露）

爬升限制：nz - z ≤ 1

下降规则：

MVP：允许任意下降（nz < z 不受限）

可选：限制最大下落高度 z - nz ≤ D

2.4.3 关于“悬空”与“粘贴”的规则说明（重要）

方块是否“有支撑”不作为移动合法性的判断条件。

只要目标位置存在可站立的顶面（2.2），即可站立与移动。

因此，关卡可以包含悬空平台、桥状结构与洞穴结构。

2.5 目标与胜利条件（Peak Reaching）

定义全局最高层为：

Zmax = max { z | 存在站点 (x,y,z) }

终点集合为所有最高站点：

Goal = { (x,y,z) | (x,y,z) 是站点 且 z == Zmax }

当玩家到达 Goal 中任一站点即通关。

2.6 自动寻路 / 提示（Pathfinding）
2.6.1 图建模

节点：所有站点 (x,y,z)

边：站点之间所有合法移动（2.4）

2.6.2 算法要求

MVP 允许使用 BFS（最短步数）或 A*（更快）

终止条件：搜索到任意 Goal 节点

2.6.3 输出格式

返回路径节点序列：

[(x0,y0,z0), (x1,y1,z1), ..., (xk,yk,zk)]

若无解，返回“无可达路径”，并在 UI 提示。

2.7 关卡数据格式（voxel 版建议）

关卡数据需能表达 3D 体素占用，推荐两种之一：

方案 A：体素坐标列表（稀疏、适合悬空）

用数组列出所有存在方块的 (x,y,z) 坐标

方案 B：按层切片（清晰、适合编辑）

每层 z 一张 2D 位图/矩阵（0/1）

MVP 建议：先用 按层切片，可读性最好，方便手工做关卡。


能不能新写一个生成方式，保存的方式跟现在一样，都是一层层的保存，但是生成的方式由 单个方块和黏在一起的2个方块堆叠而成，
单个方块和 黏一起的2方块 的数量是足够多，堆叠时悬空的情况是当其中黏在一起的2块中的一个悬空，
另一个堆叠在别的上面。这样悬空的块不至于太多，而且大部分情况的块下面都有别的块，同时个别的块是悬空。


已实现新的关卡生成方式：用“单块 + 黏在一起的双块”逐层堆叠，单块必须有下方支撑，双块允许“一个有支撑一个悬空”，从而控制悬空比例。

生成逻辑（新版本）：

先生成一条从低到高的主路径，并把路径柱子从地面一直堆到目标高度（保证可走性与单块不悬空）
逐层补充块体：每层按密度目标放置大量“单块/双块”
单块只放在有下方支撑的位置
双块只要其中一格有支撑就允许放置（另一格可悬空）
仍保留悬空邻居约束兜底，防止完全孤立的悬空块